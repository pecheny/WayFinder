# WayFinder

[Демка](https://github.com/pecheny/WayFinder/blob/master/demo/TraectoriesHx.swf?raw=true)

Очевидно, что производительность демки зависит от вероятности нахождения свободной траектории в заданных условиях. 
На это в свою очередь влияют: степень хаотичности движения, длина пробега, соотношение линейных размеров объекта и ширины экрана и т.д.
При соотношении сторон "экрана" 1/40 демка вполне свободно лопатила с полтысячи одновременно летящих объектов. 
И на таком количестве объектов более явный вклад вносила система поиска пересечений, которая сделана "в лоб".
При проектировании системы упор был сделан на гибкость и взаимозаменяимость компонентов, реализующих разные алгоритмы.

Вся логика реализована в общем виде и не знает ничего о представлении. Визуализация сделана средствами OpenFL, так как Flash API очень здорово подходит для таких задач. Тем не менее, полагаю, что запилить рендерер хоть бы и для юнити не составит труда, изменения не должны коснуться ничего в остальном коде.
Кроме рендера при переносе демки также потребовалось бы адаптировать конфигурацию сборки. Полагаю, можно просто взять  DI-контейнер под юнити и перписать конфигурацию под него. [Zenject](https://github.com/modesttree/Zenject) должен хорошо справиться с этой задачей, менеджмент `update()` тоже можно сделать его средствами через реализацию '[ITickable](https://github.com/modesttree/Zenject#itickable)'

Так, например, можно сделать кучу `TrajectoryBuilder`ов, реализующие разные алгоритмы генерации. 
Интересно было бы исслетовать влияние на производительность абсолютно случайного рандома на поиск нескольких попытнок траектории в "окрестности" раднобного выбранного значения, 
или наоборот, смещение с большим шагом.

Синуса нет, стало жаль на него времени. Стоит отметить, что есть некоторые ограничения на реализацию: при значительных наклонах синусоиды 
на некоторых участках объект может двигаться назад в проекции на ос у. Не надо так, алгоритм предполагает, что объект всегда движется вдоль оси у в одну сторону.
Если бы я стал делать синусоиду, то скорее всего из соображения экономии времени угол бы кодировал и сохранял в матрицу,  и использовал бы ее в методах расчета координат.
Вряд ли это самый производительный способ, но кажется мне разумным по соотношению с трудозатратами.

По оптимизации: не производилось никаких оптимизаций ухудшающих читаемость кода. Да вообще, по большому счету я не слишком заморачивался, сделал минимально разумное.
Вероятность появления столкновения порядка 0.1%. Я счел это приемлемым и не стал искать причины.

[Алгоритм поиска пересечений между траекториями](https://github.com/pecheny/WayFinder/blob/master/src/impl/TrajectoryResolver.hx)

[Формат задания траектории](https://github.com/pecheny/WayFinder/blob/master/src/trajectory/Trajectory.hx)

[Реализация кругленькой траетории](https://github.com/pecheny/WayFinder/blob/master/src/trajectory/circle/LeftArcTrajectory.hx) (реализована только выпуклость в одну сторону)

[Реализация прямой траектории](https://github.com/pecheny/WayFinder/blob/master/src/trajectory/line/LineTrajectory.hx)

[Генератор круглых траекторий](https://github.com/pecheny/WayFinder/blob/master/src/trajectory/circle/CircleBuilder.hx)

[Генератор прямых траекторий](https://github.com/pecheny/WayFinder/blob/master/src/trajectory/line/LineBuilder.hx)

[Генератор произвольных траекторий](https://github.com/pecheny/WayFinder/blob/master/src/trajectory/RandomTrajectoryBuilder.hx)

[Проверка столкновений](https://github.com/pecheny/WayFinder/blob/master/src/impl/DebugSystem.hx)

### Версии зависимостей

```
lime: [2.9.1] 3.0.3
minject: [1.6.1] 
openfl: [3.6.1] 4.0.3
```

